<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mysql on 牧青日志</title>
    <link>http://blog.hanmq.com/categories/mysql/</link>
    <description>Recent content in Mysql on 牧青日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 04 Feb 2017 15:38:00 +0800</lastBuildDate>
    <atom:link href="http://blog.hanmq.com/categories/mysql/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>高性能MySQL</title>
      <link>http://blog.hanmq.com/post/high-performance-mysql-01/</link>
      <pubDate>Sat, 04 Feb 2017 15:38:00 +0800</pubDate>
      
      <guid>http://blog.hanmq.com/post/high-performance-mysql-01/</guid>
      <description>

&lt;h2 id=&#34;mysql逻辑构架:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;MySQL逻辑构架&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hanmq.com/img/mysql01.png&#34; width = &#34;300&#34; alt=&#34;MySQL服务器构架逻辑图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最上层：连接处理、授权认证、安全等。&lt;/p&gt;

&lt;p&gt;中间层：大多数MySQL核心服务，查询解析、分析、优化、缓存及内置函数（日期时间、数学和加密等）。&lt;/p&gt;

&lt;p&gt;第三层：存储引擎，负责MqlSQL数据的存储和提取，服务器通过API与存储引擎通信，屏蔽了不同存储引擎之间的差异。&lt;/p&gt;

&lt;h2 id=&#34;并发控制:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;并发控制&lt;/h2&gt;

&lt;h3 id=&#34;锁:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;锁&lt;/h3&gt;

&lt;p&gt;共享锁和排它锁，也就是读锁和写锁。&lt;/p&gt;

&lt;h3 id=&#34;锁粒度:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;锁粒度&lt;/h3&gt;

&lt;p&gt;锁的开销和安全之间寻求平衡。&lt;/p&gt;

&lt;h4 id=&#34;表锁:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;表锁&lt;/h4&gt;

&lt;p&gt;MySQL中最基础的锁策略，开销最小。&lt;/p&gt;

&lt;p&gt;尽管存储引擎可以管理自己的锁，MySQL本身会使用各种有效的锁来实现不同的目的，例如在 ALTER TABLE 会使用表锁，而忽略存储引擎的锁机制。&lt;/p&gt;

&lt;h4 id=&#34;行级锁:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;行级锁&lt;/h4&gt;

&lt;p&gt;最大程度的支持并发处理（同时带来最大的锁开销），由存储引擎实现。&lt;/p&gt;

&lt;h2 id=&#34;事务:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;事务&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;原子性(atomicity)&lt;/li&gt;
&lt;li&gt;一致性(consistency)&lt;/li&gt;
&lt;li&gt;隔离型(isolation)&lt;/li&gt;
&lt;li&gt;持久性(durablility)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有存储引擎实现，所以在同一个事务中，使用多种存储引擎是不可靠的。&lt;/p&gt;

&lt;h3 id=&#34;隔离级别:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;隔离级别&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;READ UNCOMMITTED（未提交读）

&lt;ul&gt;
&lt;li&gt;事务中的修改，即使没有提交，对其他事务也是可见的。&lt;/li&gt;
&lt;li&gt;事务读到未提交数据，这称为脏读。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;READ COMMITTED（提交读），也叫不可重复读(nonrepeatable read)

&lt;ul&gt;
&lt;li&gt;满足事务的隔离性的简单定义。&lt;/li&gt;
&lt;li&gt;一个事务开始知道提交之前，所做的修改对其他事务是不可见的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;REPEATABLE READ（可重复读）

&lt;ul&gt;
&lt;li&gt;可产生幻读&lt;/li&gt;
&lt;li&gt;MySQL默认隔离级别&lt;/li&gt;
&lt;li&gt;InnoDB通过版本并发控制解决了幻读&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SERIALIZABLE（可串行化）

&lt;ul&gt;
&lt;li&gt;解决了幻读&lt;/li&gt;
&lt;li&gt;读取每一行数据加锁，可能会导致大量的超时和锁争用问题&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;多版本并发控制:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;多版本并发控制&lt;/h2&gt;

&lt;p&gt;和行级锁一样，实现了非阻塞读操作，可以说是行级锁的一个变种，但并不需要加锁操作，因此开销更低。&lt;/p&gt;

&lt;p&gt;mvcc的实现，是通过保存数据在某个时间点的快照实现的。&lt;/p&gt;

&lt;p&gt;通过两个隐藏列，创建时间和过期时间实现。&lt;/p&gt;

&lt;p&gt;mvcc只再READ COMMITTED和REPEATABLE READ两个隔离级别生效，READ UNCOMMITTED总是读最新的数据行，SERIALIZABLE会怼所有读取的行加锁。&lt;/p&gt;

&lt;h2 id=&#34;存储引擎:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;存储引擎&lt;/h2&gt;

&lt;h3 id=&#34;innodb:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;InnoDB&lt;/h3&gt;

&lt;p&gt;基于聚簇索引，对主键查询有很高的性能，耳机索引中必须包含主键列。&lt;/p&gt;

&lt;h3 id=&#34;myisam:51879d4aec6f5c72f71a4a60a0197de3&#34;&gt;MyISAM&lt;/h3&gt;

&lt;p&gt;不支持事务和行级锁。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>